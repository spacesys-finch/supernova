#ifndef SOLVERS_H
#define SOLVERS_H
#define VEC_SIZE 6 // dimension of vector (kept static at 6 for orbit prop)
#define H0810 60 // initial step
#define H01012 120 // initial step
#include <stdlib.h>
#include <math.h>

typedef struct AdaptiveSolution {
    double* t; // timesteps
    double** y; // function value
    int n; // number of steps taken
} solution;

solution* RK810vec(void (*f)(double, double[], double*), double tSpan[], double y0[], double ATOL) {
    /*
    Integrates along time points using an RK810 method using n timesteps on a vector of dimension m
    Source: https://sce.uhcl.edu/feagin/courses/rk10.pdf

    f: function for which y' = f(t, y, ARR), where ARR stores the resulting vector
    tSpan: stores (t0, tf)
    y0: array of length m containing initial conditions
    m: dimension of vector
    ord: order of method
    fname: integrator filename
    ATOL: tolerance
    */

    if (tSpan[1] <= tSpan[0]) return NULL; // error case

    ////// Initial estimate for n
    int n = (int)((tSpan[1] - tSpan[0])/H0810); // 1 step every 10 seconds
    int step = 0;

    ////// Allocate result struct
    solution* result = (solution*) malloc(sizeof(solution));
    result->y = malloc(n * sizeof(double*));
    result->t = malloc(n * sizeof(double));
    for (int i = 0; i < n; i++) result->y[i] = malloc(VEC_SIZE * sizeof(double));

    ////// Prepare Step variables
    double h = H0810; // initial stepsize
    double h_old; // previous step variable
    double t = tSpan[0]; // intial time

    // Init y0, t0 (step 0)
    for (int j = 0; j < VEC_SIZE; j++) result->y[0][j] = y0[j];
    result->t[0] = t;

    // RK Step Parameters from https://sce.uhcl.edu/rungekutta/rk108.txt
    // a coefficients (written at beta in the paper) [intermediate solution weights]
    double a[17][16] ={
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-0.9151765613752915, 1.4545344021782731, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.20225919030111816, 0.0, 0.6067775709033545, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.18402471470864357, 0.0, 0.19796683122719236, -0.07295478473136326, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.08790073402066813, 0.0, 0.0, 0.41045970252026065, 0.4827137536788665, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.08597005049024603, 0.0, 0.0, 0.3308859630407222, 0.4896629573094502, -0.07318563750708508, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.12093044912533372, 0.0, 0.0, 0.0, 0.2601246757582956, 0.032540262154909134, -0.0595780211817361, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.11085437958039149, 0.0, 0.0, 0.0, 0.0, -0.06057614882550056, 0.3217637056017784, 0.510485725608063, 0, 0, 0, 0, 0, 0, 0, 0},
    {0.112054414752879, 0.0, 0.0, 0.0, 0.0, -0.14494277590286592, -0.3332697190962567, 0.4992692295568801, 0.5095046089296861, 0, 0, 0, 0, 0, 0, 0},
    {0.11397678396418598, 0.0, 0.0, 0.0, 0.0, -0.07688133642033569, 0.23952736032439065, 0.3977746623680946, 0.010755895687360746, -0.3277691241640189, 0, 0, 0, 0, 0, 0},
    {0.07983145282801961, 0.0, 0.0, 0.0, 0.0, -0.052032968680060306, -0.05769541461685489, 0.19478191571210415, 0.14538492318832508, -0.07829427103516708, -0.11450329936109892, 0, 0, 0, 0, 0},
    {0.9851156101648573, 0.0, 0.0, 0.3308859630407222, 0.4896629573094502, -1.3789648657484357, -0.8611641950276356, 5.784288136375372, 3.2880776198510357, -2.386339050931364, -3.254793424836439, -2.16343541686423, 0, 0, 0, 0},
    {0.8950802957716328, 0.0, 0.19796683122719236, -0.07295478473136326, 0.0, -0.8512362396620076, 0.3983201123185333, 3.639372631810356, 1.5482287703983033, -2.122217147040537, -1.5835039854532618, -1.7156160828593627, -0.024403640575012746, 0, 0, 0},
    {-0.9151765613752915, 1.4545344021782731, 0.0, 0.0, -0.7773336436449683, 0.0, -0.0910895662155176, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0910895662155176, 0.7773336436449683, 0, 0},
    {0.1, 0.0, -0.15717866579977116, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15717866579977116, 0},{0.1817813007000953, 0.675, 0.3427581598471898, 0.0, 0.25911121454832275, -0.35827896671795206, -1.0459489594088331, 0.930327845415627, 1.7795095943170811, 0.1, -0.2825475695390441, -0.15932735011997254, -0.14551589464700151, -0.25911121454832275, -0.3427581598471898, -0.675}};
    
    // c coefficients (written as a in the paper) [intermediate timestep values]
    double c[17] = { 0.000000000000000000000000000000000000000000000000000000000000,0.100000000000000000000000000000000000000000000000000000000000,0.539357840802981787532485197881302436857273449701009015505500,0.809036761204472681298727796821953655285910174551513523258250,0.309036761204472681298727796821953655285910174551513523258250,0.981074190219795268254879548310562080489056746118724882027805,0.833333333333333333333333333333333333333333333333333333333333,0.354017365856802376329264185948796742115824053807373968324184,0.882527661964732346425501486979669075182867844268052119663791,0.642615758240322548157075497020439535959501736363212695909875,0.357384241759677451842924502979560464040498263636787304090125,0.117472338035267653574498513020330924817132155731947880336209,0.833333333333333333333333333333333333333333333333333333333333,0.309036761204472681298727796821953655285910174551513523258250,0.539357840802981787532485197881302436857273449701009015505500,0.100000000000000000000000000000000000000000000000000000000000,1.00000000000000000000000000000000000000000000000000000000000};

    // b coefficeints (written as c in the paper) [solution weights]
    double b[17] = {0.0333333333333333333333333333333333333333333333333333333333333,0.0250000000000000000000000000000000000000000000000000000000000,0.0333333333333333333333333333333333333333333333333333333333333,0.000000000000000000000000000000000000000000000000000000000000,0.0500000000000000000000000000000000000000000000000000000000000,0.000000000000000000000000000000000000000000000000000000000000,0.0400000000000000000000000000000000000000000000000000000000000,0.000000000000000000000000000000000000000000000000000000000000,0.189237478148923490158306404106012326238162346948625830327194,0.277429188517743176508360262560654340428504319718040836339472,0.277429188517743176508360262560654340428504319718040836339472,0.189237478148923490158306404106012326238162346948625830327194,-0.0400000000000000000000000000000000000000000000000000000000000,-0.0500000000000000000000000000000000000000000000000000000000000,-0.0333333333333333333333333333333333333333333333333333333333333,-0.0250000000000000000000000000000000000000000000000000000000000,0.0333333333333333333333333333333333333333333333333333333333333};

    // Create Step Variables
    double k[17][VEC_SIZE]; // k values
    double y_i[VEC_SIZE]; // function inputs at each step
    double y_curr[VEC_SIZE]; // current solution array, and also used to update itself for next step

    double err; // magnitude of error

    /////// INTEGRATION STEPS
    while (t-h < tSpan[1]) {
        for (int j = 0; j < VEC_SIZE; j++) y_curr[j] = result->y[step][j]; // get current y (for vectorization purposes)

        f(t, y_curr, k[0]); // RK Stage 0

        // Perform all RK Stages [1, s)
        for (int r = 1; r < 17; r++) {
            //// Prepare input vector
            for (int j = 0; j < VEC_SIZE; j++) {             
                y_i[j] = y_curr[j]; // take current sol      
                for (int w = 0; w < r; w++) y_i[j] += h * k[w][j] * a[r][w]; // Add previous steps
            }
            f(t + h * c[r], y_i, k[r]); // evaluate next k
        }

        // Calculate error using error estimate formula from paper
        // take abs value of all errors as convervative estimate
        err = 0;
        for (int j = 0; j < VEC_SIZE; j++) err += fabs(1.0/360.0 * h * (k[1][j] - k[15][j]));

        //// Step size adjustment
        // Determine new step size
        h_old = h;
        h = 0.9 * h * pow(ATOL/err, 1.0/9.0); // next step size (based on ninth order local error)

        if (err < ATOL) {
            /// step within tolerance, append solution
            // check array size and increase size if needed
            if ((step + 1) >= n) {
                n *= 2;
                result->y = realloc(result->y, n * sizeof(double*));
                result->t = realloc(result->t, n * sizeof(double));
                for (int i = step + 1; i < n; i++) result->y[i] = malloc(VEC_SIZE * sizeof(double));
            }

            // Append to result
            for (int j = 0; j < VEC_SIZE; j++) {
                for (int r = 0; r < 17; r++) y_curr[j] += h_old * b[r] * k[r][j]; // Add all weights
            }
            for (int j = 0; j < VEC_SIZE; j++) result->y[step+1][j] = y_curr[j]; // write (separated for vectorization)

            step++; // advance step
            t += h_old; // advance time
            result->t[step] = t; // record time
        }
        // Otherwise, retry step
    }
    // record # of steps after finish
    result->n = step;

    return result;
}

solution* RK1012vec(void (*f)(double, double[], double*), double tSpan[], double y0[], double ATOL) {
    /*
    Integrates along time points using an RK1012 method using n timesteps on a vector of dimension m
    Source: https://sce.uhcl.edu/rungekutta/rk1210.txt

    f: function for which y' = f(t, y, ARR), where ARR stores the resulting vector
    tSpan: stores (t0, tf)
    y0: array of length m containing initial conditions
    m: dimension of vector
    ord: order of method
    fname: integrator filename
    ATOL: tolerance
    */

    if (tSpan[1] <= tSpan[0]) return NULL; // error case

    ////// Initial estimate for n
    int n = (int)((tSpan[1] - tSpan[0])/H01012); // 1 step every 10 seconds
    int step = 0;

    ////// Allocate result struct
    solution* result = (solution*) malloc(sizeof(solution));
    result->y = malloc(n * sizeof(double*));
    result->t = malloc(n * sizeof(double));
    for (int i = 0; i < n; i++) result->y[i] = malloc(VEC_SIZE * sizeof(double));

    ////// Prepare Step variables
    double h = H01012; // initial stepsize
    double h_old; // previous step variable
    double t = tSpan[0]; // intial time

    // Init y0, t0 (step 0)
    for (int j = 0; j < VEC_SIZE; j++) result->y[0][j] = y0[j];
    result->t[0] = t;

    // RK Step Parameters
    // a coefficients (written at beta in the paper) [intermediate solution weights]
    double a[25][24] ={{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {-0.21604938271604937, 0.7716049382716049, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.20833333333333334, 0.0, 0.625, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.19333333333333333, 0.0, 0.22, -0.08, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.1, 0.0, 0.0, 0.4, 0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.10336447165001048, 0.0, 0.0, 0.12405309452894676, 0.4831711675610329, -0.038753024569476324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.12403826143183333, 0.0, 0.0, 0.0, 0.21705063219795848, 0.013745579207596677, -0.06610953172676828, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.0914774894856883, 0.0, 0.0, 0.0, 0.0, -0.005443485237174697, 0.06807168016884535, 0.40839431558264105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.08900136525025511, 0.0, 0.0, 0.0, 0.0, 0.004995282266455323, 0.397918238819829, 0.4279302107525766, -0.0865117637557827, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.06950876241349076, 0.0, 0.0, 0.0, 0.0, 0.12914694190017645, 1.530736381023113, 0.57787476112914, -0.9512947723210889, -0.40827664296563193, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.044486140329513583, 0.0, 0.0, 0.0, 0.0, -0.0038047686705696172, 0.01069550640296242, 0.020961624449990432, -0.023314602325932177, 0.0026326598106453697, 0.0031547276897702504, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.019458881511975546, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.785129491718125e-05, -4.297958590492736e-05, 1.7635898226028515e-05, 0.0653866627415027, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.2068368356642771, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.016679606710415646, -0.008795015632007103, 0.003466754553624639, -0.8612644601057177, 0.9086518820740502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.0203926084654484, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0869469392016686, -0.019164963041014983, 0.006556291594936633, 0.09874761281274348, 0.005353646955249961, 0.3011678640109679, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {0.2284104339177781, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.4987074007930252, 0.1348411683357245, -0.03874582440558342, -1.2747325747347484, 1.4391636446287717, -0.21400746796799025, 0.9582024177544303, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                      {2.002224776559742, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.067018099615249, 0.6239781360861395, -0.046228368550031144, -8.849732883626496, 7.7425770785085595, -0.5883585192508692, -1.1068373336238064, -0.929529037579204, 0, 0, 0, 0, 0, 0, 0, 0},
                      {3.1378953341207345, 0.0, 0.0, 0.0, 0.0, 0.12914694190017645, 1.530736381023113, 0.57787476112914, 5.420882630551267, 0.2315469260348293, 0.07592929955789135, -12.372997338018651, 9.854558834647696, 0.08591114313704365, -5.652427528626439, -1.9430093524281962, -0.12835260184940453, 0, 0, 0, 0, 0, 0, 0},
                      {1.3836005443219601, 0.0, 0.0, 0.0, 0.0, 0.004995282266455323, 0.397918238819829, 0.4279302107525766, -1.3029910742447577, 0.661292278669377, -0.14455977430695435, -6.965760347317982, 6.6580854323599175, -1.669973751088415, 2.064137023180353, -0.6747439626443065, -0.001156188347949395, -0.005440579086770074, 0, 0, 0, 0, 0, 0},
                      {0.9512362970482877, 0.0, 0.0, 0.0, 0.21705063219795848, 0.013745579207596677, -0.06610953172676828, 0.0, 0.15228169673641445, -0.33774101835759984, -0.019282598163399577, -3.682592696968668, 3.1619787040698206, -0.3704625221068853, -0.05149742003654404, -0.0008296255321201529, 2.798010414192786e-06, 0.041860391641236026, 0.27908425509087736, 0, 0, 0, 0, 0},
                      {0.10336447165001048, 0.0, 0.0, 0.12405309452894676, 0.4831711675610329, -0.038753024569476324, 0.0, -0.43831382036112243, 0.0, -0.21863663372167666, -0.031233476439471924, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.031233476439471924, 0.21863663372167666, 0.43831382036112243, 0, 0, 0, 0},
                      {0.19333333333333333, 0.0, 0.22, -0.08, 0.0, 0.0, 0.0984256130499316, -0.19641088922305466, 0.0, 0.43645793049306875, 0.06526137216757211, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.06526137216757211, -0.43645793049306875, 0.19641088922305466, -0.0984256130499316, 0, 0, 0},
                      {-0.21604938271604937, 0.7716049382716049, 0.0, 0.0, -0.6666666666666666, 0.0, -0.39069646929597845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.39069646929597845, 0.6666666666666666, 0, 0},
                      {0.2, 0.0, -0.1646090534979424, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1646090534979424, 0},
                      {1.4717872488111041, 0.7875, 0.4212962962962963, 0.0, 0.2916666666666667, 0.0, 0.34860071762832956, 0.22949954476899484, 5.79046485790482, 0.4185875118565069, 0.307039880222474, -4.687009053506033, 3.1357166559380225, 1.4013482971096571, -5.52931101439499, -0.8531382355080633, 0.10357578037361014, -0.14047441695060095, -0.4185875118565069, -0.22949954476899484, -0.34860071762832956, -0.2916666666666667, -0.4212962962962963, -0.7875}};
    // c coefficients (written as a in the paper) {intermediate timestep values}
    double c[25] = { 0.0, 0.2, 0.5555555555555556, 0.8333333333333334, 0.3333333333333333, 1.0, 0.6718357091705138, 0.2887249411106202, 0.5625, 0.8333333333333334, 0.9476954311791993, 0.054811287686380265, 0.08488805186071653, 0.2655756032646429, 0.5, 0.7344243967353571, 0.9151119481392834, 0.9476954311791993, 0.8333333333333334, 0.2887249411106202, 0.6718357091705138, 0.3333333333333333, 0.5555555555555556, 0.2, 1.0};

    // b coefficeints (written as c in the paper) [solution weights]
    double b[25] = {0.023809523809523808, 0.0234375, 0.03125, 0.0, 0.041666666666666664, 0.0, 0.05, 0.05, 0.0, 0.1, 0.07142857142857142, 0.0, 0.13841302368078298, 0.2158726906049313, 0.2438095238095238, 0.2158726906049313, 0.13841302368078298, -0.07142857142857142, -0.1, -0.05, -0.05, -0.041666666666666664, -0.03125, -0.0234375, 0.023809523809523808};

    // Create Step Variables
    double k[25][VEC_SIZE]; // k values
    double y_i[VEC_SIZE]; // function inputs at each step
    double y_curr[VEC_SIZE]; // current solution array, and also used to update itself for next step

    double err; // magnitude of error

    /////// INTEGRATION STEPS
    while (t-h < tSpan[1]) {
        for (int j = 0; j < VEC_SIZE; j++) y_curr[j] = result->y[step][j]; // get current y (for vectorization purposes)

        f(t, y_curr, k[0]); // RK Stage 0

        // Perform all RK Stages [1, 25)
        for (int r = 1; r < 25; r++) {
            //// Prepare input vector
            for (int j = 0; j < VEC_SIZE; j++) {             
                y_i[j] = y_curr[j]; // take current sol      
                for (int w = 0; w < r; w++) y_i[j] += h * k[w][j] * a[r][w]; // Add previous steps
            }
            f(t + h * c[r], y_i, k[r]); // evaluate next k
        }

        // Calculate error using error estimate formula from paper
        // take abs value of all errors as convervative estimate
        err = 0;
        for (int j = 0; j < VEC_SIZE; j++) err += fabs(49.0/640.0 * h * (k[1][j] - k[23][j]));

        //// Step size adjustment
        // Determine new step size
        h_old = h;
        h = 0.9 * h * pow(ATOL/err, 1.0/11.0); // next step size (based on eleventh order local error)

        if (err < ATOL) {
            /// step within tolerance, append solution
            // check array size and increase size if needed
            if ((step + 1) >= n) {
                n *= 2;
                result->y = realloc(result->y, n * sizeof(double*));
                result->t = realloc(result->t, n * sizeof(double));
                for (int i = step + 1; i < n; i++) result->y[i] = malloc(VEC_SIZE * sizeof(double));
            }

            // Append to result
            for (int j = 0; j < VEC_SIZE; j++) {
                for (int r = 0; r < 25; r++) y_curr[j] += h_old * b[r] * k[r][j]; // Add all weights
            }
            for (int j = 0; j < VEC_SIZE; j++) result->y[step+1][j] = y_curr[j]; // write (separated for vectorization)

            step++; // advance step
            t += h_old; // advance time
            result->t[step] = t; // record time
        }
        // Otherwise, retry step
    }
    // record # of steps after finish
    result->n = step;

    return result;
}

#endif